# -*- coding: utf-8 -*-

LDAP Nodes
==========

::

    >>> from node.ext.ldap import LDAPProps
    >>> from node.ext.ldap import LDAPNode
    >>> from node.ext.ldap.testing import props

Create the root node. The Root node expects the initial base DN as name and
the server properties::

    >>> LDAPNode('dc=my-domain,dc=com')
    Traceback (most recent call last):
    ...
    ValueError: Wrong initialization.
  
    >>> LDAPNode(props=props)
    Traceback (most recent call last):
    ...
    ValueError: Wrong initialization.
  
    >>> root = LDAPNode('dc=my-domain,dc=com', props)
    >>> root
    <dc=my-domain,dc=com - False>

The non-unicode name got decoded::

    >>> root.name
    u'dc=my-domain,dc=com'
    
    >>> root.rdn_attr
    u'dc'

LDAP attributes for DN are stored on ``attrs``::

    >>> root.attrs
    <LDAPNodeAttributes object 'dc=my-domain,dc=com' at ...>

The node has session::

    >>> root.ldap_session
    <node.ext.ldap.session.LDAPSession object at ...>

Check child keys of root::

    >>> root.keys()
    [u'ou=customers']

Check/modify attributes of root::

    >>> root.attrs.items()
    [(u'objectClass', [u'top', u'dcObject', u'organization']),
     (u'dc', u'my-domain'),
     (u'o', u'my-organization')]

    >>> root.attrs['o'] = 'foo'

On ``__call__`` data gets persisted::

    >>> root()
    >>> root.attrs.items()
    [(u'objectClass', [u'top', u'dcObject', u'organization']),
     (u'dc', u'my-domain'),
     (u'o', u'foo')]

Recreate root and check changed attributes::

    >>> root = LDAPNode('dc=my-domain,dc=com', props)
    >>> root.attrs.items()
    [(u'objectClass', [u'top', u'dcObject', u'organization']), 
    (u'dc', u'my-domain'), 
    (u'o', u'foo')]

Reset o::

    >>> root.attrs['o'] = 'my-organization'
    >>> root()

Access inexistent child::

    >>> foo = root['foo']
    Traceback (most recent call last):
    ...
    KeyError: u'Entry not existent: foo'

Access existent child and it's attributes::
  
    >>> customers = root['ou=customers']
    >>> customers
    <ou=customers,dc=my-domain,dc=com:ou=customers - False>
  
    >>> customers.attrs.items()
    [(u'objectClass', [u'top', u'organizationalUnit']), 
    (u'ou', u'customers'), 
    (u'description', u'customers'), 
    (u'businessCategory', u'customers')]

    >>> customers.DN
    u'ou=customers,dc=my-domain,dc=com'

    >>> customers.name
    u'ou=customers'
    
    >>> customers.rdn_attr
    u'ou'

Customers child keys::

    >>> customers.keys()
    [u'ou=customer1', u'ou=customer2', u'ou=n\xe4sty\\, customer']

XXX: why is this a list???
     maybe python-ldap bug or even openldap bug
     also behaves this way when queried with LDAPCommunicator.search
    >>> customers[u'ou=n\xe4sty\\, customer'].attrs['ou']
    [u'n\xe4sty\\, customer', u'n\xe4sty, customer']

Customer has not been changed::

    >>> customers.changed
    False

Create new LDAPNode and add it to customers::

    >>> customer = LDAPNode()
    >>> customer.attrs['ou'] = 'customer3'
    >>> customer.attrs['description'] = 'customer3'
    >>> customer.attrs['objectClass'] = ['top', 'organizationalUnit']
    >>> customer.DN
    u''
    
    >>> print customer.rdn_attr
    None
    
    >>> customer.attrs['ou']
    u'customer3'
    
    >>> customer.attrs['objectClass']
    ['top', 'organizationalUnit']
    
    >>> customer.keys()
    []

There is not LDAP session set. Customer not part of tree yet::

    >>> customer.ldap_session is None
    True

Tree has not changed yet::

    >>> root.printtree()
    <dc=my-domain,dc=com - False>
      <ou=customers,dc=my-domain,dc=com:ou=customers - False>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>

Set already created customer::

    >>> customers['ou=customer3'] = customer
    >>> customer.DN
    u'ou=customer3,ou=customers,dc=my-domain,dc=com'

Now it got the LDAP session which is used by the whole tree::

    >>> customer.ldap_session
    <node.ext.ldap.session.LDAPSession object at ...>
    
    >>> root.ldap_session is customer.ldap_session
    True

Now tree nodes from customer up to root are flagged changed after adding the
new node::

    >>> root.printtree()
    <dc=my-domain,dc=com - True>
      <ou=customers,dc=my-domain,dc=com:ou=customers - True>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - True>

New entry has no childs, but was added to the parent. There
was a bug where iteration tried to load from ldap at this stage. Lets test
if this works::

    >>> customer.keys()
    []

Data has changed in memory, but not persisted yet to LDAP::

    >>> customers.keys()
    [u'ou=customer1', u'ou=customer2', u'ou=n\xe4sty\\, customer', u'ou=customer3']

The Container has changed...::
 
    >>> customers.changed
    True

...but there's no action on the container since a child was added and the
attributes of the contained has not been changed::

    >>> print customers._action
    None

The added child has been flagged changed as well...::

    >>> customer.changed
    True

...and now there's also the action set that it has to be added::

    >>> from node.ext.ldap._node import (
    ...     ACTION_ADD,
    ...     ACTION_MODIFY,
    ...     ACTION_DELETE,
    ... )
    >>> customer._action is ACTION_ADD
    True

Check the backend state, not added yet::

    >>> res = customers.ldap_session.search('(objectClass=*)',
    ...                                     1,
    ...                                     baseDN=customers.DN,
    ...                                     force_reload=True)
    >>> len(res)
    3

On call the new entry is written to the directory::
    
    >>> root()
    >>> res = customers.ldap_session.search('(objectClass=*)',
    ...                                     1,
    ...                                     baseDN=customers.DN,
    ...                                     force_reload=True)
    >>> len(res)
    4

All nodes are flagged unchanged again::

    >>> root.printtree()
    <dc=my-domain,dc=com - False>
      <ou=customers,dc=my-domain,dc=com:ou=customers - False>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - False>

Add a person to test modification stuff::

    >>> person = LDAPNode()
    >>> person.attrs['objectClass'] = ['top', 'person']
    >>> person.attrs['sn'] = 'Mustermann'
    >>> person.attrs['cn'] = 'Max'
    >>> person.attrs['description'] = 'Initial Description'
    >>> customer['cn=max'] = person
    >>> customer.keys()
    [u'cn=max']
    
    >>> person.DN
    u'cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com'
  
Again, not in directory yet::

    >>> res = customer.ldap_session.search('(objectClass=person)',
    ...                                    1,
    ...                                    baseDN=customer.DN,
    ...                                    force_reload=True)
    >>> len(res)
    0

Let's also change the container of the person::

    >>> customer.attrs['street'] = 'foo'

And tell the person to commit its changes. The container (customer3) is still
changed because of its changed attributes::

    >>> person()
    >>> root.printtree()
    <dc=my-domain,dc=com - True>
      <ou=customers,dc=my-domain,dc=com:ou=customers - True>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - True>
          <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=max - False>

Call the customer now, whole tree unchanged again::

    >>> customer()
    >>> root.printtree()
    <dc=my-domain,dc=com - False>
      <ou=customers,dc=my-domain,dc=com:ou=customers - False>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - False>
          <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=max - False>

Now we change the person and customer again, and discard the attribute change 
of the customer. It must not delete the changed state of the whole tree, as the
person is still changed::

    >>> customer.attrs['street'] = 'foo'
    >>> person.attrs['description'] = 'foo'
    >>> root.printtree()
    <dc=my-domain,dc=com - True>
      <ou=customers,dc=my-domain,dc=com:ou=customers - True>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - True>
          <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=max - True>
    
    >>> customer.attrs.load()
    >>> root.printtree()
    <dc=my-domain,dc=com - True>
      <ou=customers,dc=my-domain,dc=com:ou=customers - True>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - True>
          <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=max - True>

After calling person, the whole tree is unchanged again::

    >>> person()
    >>> root.printtree()
    <dc=my-domain,dc=com - False>
      <ou=customers,dc=my-domain,dc=com:ou=customers - False>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - False>
          <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=max - False>

Changing attributes of a node, where keys are not loaded, yet::

    >>> from node.ext.ldap import queryNode
    >>> dn = 'cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com'
    >>> tmp = queryNode(props, dn)
    >>> tmp.attrs['description'] = 'Initial Description'
    >>> tmp()

Check set child immediately after init time::

    >>> tmp = LDAPNode('ou=customers,dc=my-domain,dc=com', props=props)
    >>> tmp['cn=child'] = LDAPNode()
    >>> tmp.keys()
    [u'ou=customer1', u'ou=customer2', 
    u'ou=n\xe4sty\\, customer', u'ou=customer3', u'cn=child']

Secondary keys and _child_dns.

Setting the DN as seckey only seem to work because it is returned by LDAP
search result and considered. Child DN's are always available at _child_dns

XXX: discuss::
    
    >>> tmp = LDAPNode('ou=customers,dc=my-domain,dc=com', props=props)
    >>> tmp._seckey_attrs = ('cn',)
    >>> tmp.keys()
    Traceback (most recent call last):
      ...
    KeyError: u"Secondary key 'cn' missing on: ou=customer1,ou=customers,dc=my-domain,dc=com."

    >>> tmp = LDAPNode('ou=customers,dc=my-domain,dc=com', props=props)
    >>> tmp._seckey_attrs = ('dn',)
    >>> tmp.keys()
    [u'ou=customer1', 
    u'ou=customer2', 
    u'ou=n\xe4sty\\, customer', 
    u'ou=customer3']
    
    >>> tmp = LDAPNode('ou=customers,dc=my-domain,dc=com', props=props)
    >>> tmp._seckey_attrs = ('description', 'businessCategory')
    >>> tmp.keys()
    Traceback (most recent call last):
      ...
    KeyError: u"Secondary key not unique: businessCategory='customers'."
    
    >>> tmp = LDAPNode('ou=customers,dc=my-domain,dc=com', props=props)
    >>> tmp._seckey_attrs = ('dn', 'objectClass')
    >>> tmp.keys()
    Traceback (most recent call last):
      ...
    KeyError: u"Expected one value for 
    'objectClass' not 2: '[u'top', u'organizationalUnit']'."

    >>> tmp = LDAPNode('ou=customers,dc=my-domain,dc=com', props=props)
    >>> tmp._seckey_attrs = ('dn', 'description')
    >>> tmp.keys()
    [u'ou=customer1', 
    u'ou=customer2', 
    u'ou=n\xe4sty\\, customer', 
    u'ou=customer3']
    
    >>> tmp._child_dns
    {u'ou=n\xe4sty\\, customer': 
    u'ou=n\xe4sty\\2C customer,ou=Customers,dc=My-Domain,dc=com', 
    u'ou=customer3': 
    u'ou=customer3,ou=customers,dc=my-domain,dc=com', 
    u'ou=customer2': 
    u'ou=customer2,ou=customers,dc=my-domain,dc=com', 
    u'ou=customer1': 
    u'ou=customer1,ou=customers,dc=my-domain,dc=com'}

    >>> tmp._seckeys
    {'dn': 
    {u'ou=customer2,ou=customers,dc=my-domain,dc=com': u'ou=customer2', 
    u'ou=customer1,ou=customers,dc=my-domain,dc=com': u'ou=customer1', 
    u'ou=customer3,ou=customers,dc=my-domain,dc=com': u'ou=customer3', 
    u'ou=n\xe4sty\\2C customer,ou=Customers,dc=My-Domain,dc=com': u'ou=n\xe4sty\\, customer'}, 
    'description': 
    {u'customer1': u'ou=customer1', 
    u'n\xe4sty': u'ou=n\xe4sty\\, customer', 
    u'customer3': u'ou=customer3', 
    u'customer2': u'ou=customer2'}}
    
    >>> tmp = LDAPNode('ou=customers,dc=my-domain,dc=com', props=props)
    >>> tmp.keys()
    [u'ou=customer1', 
    u'ou=customer2', 
    u'ou=n\xe4sty\\, customer', 
    u'ou=customer3']
    
    >>> tmp._child_dns
    {u'ou=n\xe4sty\\, customer': 
    u'ou=n\xe4sty\\2C customer,ou=Customers,dc=My-Domain,dc=com', 
    u'ou=customer3': 
    u'ou=customer3,ou=customers,dc=my-domain,dc=com', 
    u'ou=customer2': 
    u'ou=customer2,ou=customers,dc=my-domain,dc=com', 
    u'ou=customer1': 
    u'ou=customer1,ou=customers,dc=my-domain,dc=com'}
    
    >>> print tmp._seckeys
    None

Changing the rdn attribute on loaded nodes fails.::

    >>> person.attrs['cn'] = 'foo'
    >>> person()
    Traceback (most recent call last):
      ...
    NAMING_VIOLATION: {'info': "value of naming attribute 'cn' is not present in entry", 'desc': 'Naming violation'}
    
    >>> person.attrs.load()
    >>> person.attrs['cn']
    u'Max'

Create Customer convenience query function. Need this more than once::

    >>> def queryPersonDirectly():
    ...     res = customer.ldap_session.search('(objectClass=person)',
    ...                                        1,
    ...                                        baseDN=customer.DN,
    ...                                        force_reload=True)
    ...     return res
  
    >>> pprint(queryPersonDirectly())
    [(u'cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com',
      {u'cn': [u'Max'],
       u'description': [u'Initial Description'],
       u'objectClass': [u'top', u'person'],
       u'sn': [u'Mustermann']})]

Lets modify this person. First look at the flags::

    >>> root.changed, customer.changed, person.changed
    (False, False, False)
  
    >>> person._action

    >>> person.attrs.changed
    False

Now modify::
    
    >>> person.attrs['description'] = 'Another description'
    >>> person.attrs.changed
    True
  
    >>> person._action == ACTION_MODIFY
    True

    >>> root.changed, customer.changed, person.changed
    (True, True, True)

Write changed to directory::

    >>> root()
    
Check the flags::

    >>> root.changed, customer.changed, person.changed
    (False, False, False)

And check the changes in the directory::

    >>> pprint(queryPersonDirectly())
    [(u'cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com',
      {u'cn': [u'Max'],
       u'description': [u'Another description'],
       u'objectClass': [u'top', u'person'],
       u'sn': [u'Mustermann']})]

Check removing of an attribute::
  
    >>> root.changed, customer.changed, person.changed, \
    ... person.attrs.changed
    (False, False, False, False)

    >>> del person.attrs['description']
    >>> root.changed, customer.changed, person.changed, \
    ... person.attrs.changed
    (True, True, True, True)

We can call a node in the middle::

    >>> customer()
    >>> pprint(queryPersonDirectly())
    [(u'cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com',
      {u'cn': [u'Max'], 
      u'objectClass': [u'top', u'person'], 
      u'sn': [u'Mustermann']})]

    >>> root.changed, customer.changed, person.changed, \
    ... person.attrs.changed
    (False, False, False, False)

Check adding of an attribute::

    >>> person.attrs['description'] = u'Brandnew description'
    >>> root.changed, customer.changed, person.changed, \
    ... person.attrs.changed
    (True, True, True, True)

    >>> customer()
    >>> pprint(queryPersonDirectly())
    [(u'cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com',
      {u'cn': [u'Max'],
       u'description': [u'Brandnew description'],
       u'objectClass': [u'top', u'person'],
       u'sn': [u'Mustermann']})]

    >>> root.changed, customer.changed, person.changed, \
    ... person.attrs.changed
    (False, False, False, False)

Attribute with non-ascii unicode returns as is::

    >>> person.attrs['sn'] = u'i\u0107'
    >>> person()
    >>> queryPersonDirectly()[0][1]['sn'][0]
    u'i\u0107'

Attribute with non-ascii str (utf8) returns as unicode::

    >>> person.attrs['sn'] = 'i\xc4\x87'
    >>> person()
    >>> queryPersonDirectly()[0][1]['sn'][0]
    u'i\u0107'

# XXX: Don't test this until we have proper binary attr support
#Attribute with utf16 str fails::
#
#    >> person.attrs['sn'] = '\xff\xfei\x00\x07\x01'
#    Traceback (most recent call last):
#    ...
#    UnicodeDecodeError:
#      'utf8' codec can't decode byte 0xff in position 0: unexpected code byte

Check queryNode with nästy dn. (see node.__repr__)::

    >>> node = queryNode(props, \
    ...     r'ou=nästy\, customer,ou=customers,dc=my-domain,dc=com')
    >>> node.__name__
    u'ou=n\xe4sty\\, customer'
    
    >>> node
    <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
    
    >>> node.parent
    <ou=customers,dc=my-domain,dc=com - False>

Check access to attributes on a fresh but added-to-parent node. There was a bug
so we test it. Note that rdn attribute is computed from key if not set yet::

    >>> customerattrempty = LDAPNode()
    >>> customers['cn=customer99'] = customerattrempty
    >>> customerattrempty.attrs.keys()
    [u'cn']

Add some attributes to make call work::
    
    >>> customerattrempty.attrs['objectClass'] = \
    ...     ['organizationalRole', 'simpleSecurityObject']
    >>> customerattrempty.attrs['userPassword'] = 'fooo'

Check deleting of entries::

    >>> root.printtree()
    <dc=my-domain,dc=com - True>
      <ou=customers,dc=my-domain,dc=com:ou=customers - True>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - False>
          <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=max - False>
        <cn=customer99,ou=customers,dc=my-domain,dc=com:cn=customer99 - True>

    >>> [k for k in customer._keys]
    [u'cn=max']

    >>> del customer['cn=max']
    >>> root.changed, customer.changed, person.changed, \
    ... person.attrs.changed
    (True, True, True, False)
    
    >>> [k for k in customer._keys]
    []

    >>> root.printtree()
    <dc=my-domain,dc=com - True>
      <ou=customers,dc=my-domain,dc=com:ou=customers - True>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - True>
        <cn=customer99,ou=customers,dc=my-domain,dc=com:cn=customer99 - True>
    
    >>> customer()
    >>> queryPersonDirectly()
    []

    >>> root.printtree()
    <dc=my-domain,dc=com - True>
      <ou=customers,dc=my-domain,dc=com:ou=customers - True>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - False>
        <cn=customer99,ou=customers,dc=my-domain,dc=com:cn=customer99 - True>

    >>> root.changed, customer.changed
    (True, False)
    
    >>> customerattrempty()
    >>> root.printtree()
    <dc=my-domain,dc=com - False>
      <ou=customers,dc=my-domain,dc=com:ou=customers - False>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - False>
        <cn=customer99,ou=customers,dc=my-domain,dc=com:cn=customer99 - False>

Test LDAPNode.child_defaults. A default value can either be a string or a
callback accepting the container node and the child key with which the new
child gets added.::

    >>> defaults = {
    ...     'objectClass': ['top', 'person'],
    ...     'sn': lambda x, y: 'sn for %s' % y,
    ...     'description': lambda x, y: 'Description for %s' % y,
    ... }

Define child defaults for customer. It's possible to set an LDAPNodeDefaults
instance if a custom callback context is desired::

    >>> customer.child_defaults = defaults
    >>> person = LDAPNode()
    >>> customer['cn=person_with_default1'] = person
    >>> person.attrs.items()
    [(u'cn', u'person_with_default1'), 
    (u'objectClass', ['top', 'person']), 
    (u'sn', u'sn for cn=person_with_default1'), 
    (u'description', u'Description for cn=person_with_default1')]
    
    >>> person()
    >>> del customer['cn=person_with_default1']
    >>> customer()

It's possible to add other INode implementing objects than LDAPNode. An ldap
node gets created then and attrs are set from original node.

    >>> from node.base import BaseNode
    >>> new = BaseNode()
    >>> customer['cn=from_other'] = new
    Traceback (most recent call last):
      ...
    ValueError: No attributes found on vessel, cannot convert
    
    >>> from node.base import AttributedNode
    >>> new = AttributedNode()
    >>> new.attrs['description'] = 'Not from defaults'
    >>> customer['cn=from_other'] = new
    >>> customer()
    >>> customer['cn=from_other']
    <cn=from_other,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=from_other - False>
    
    >>> customer['cn=from_other'].attrs.items()
    [(u'description', u'Not from defaults'), 
    (u'cn', u'from_other'), 
    (u'objectClass', ['top', 'person']), 
    (u'sn', u'sn for cn=from_other')]
    
    >>> del customer['cn=from_other']
    >>> customer()

Test search function::

    >>> root.search()
    [u'ou=customers']
    
    >>> from node.ext.ldap.filter import LDAPFilter
    >>> filter = LDAPFilter('(objectClass=person)')
    >>> root.search(queryFilter=filter)
    []
    
    >>> root.search(attrlist=['ou'])
    [(u'ou=customers', {u'ou': [u'customers']})]

###############################################################################
Experimental features below
###############################################################################

Using some other attribute as key, instead of the RDN. Let's first add two
person's the way we know it::

    >>> p1 = LDAPNode()
    >>> p1.attrs['objectClass'] = ['top', 'person']
    >>> p1.attrs['sn'] = 'Mustermann'
    >>> p1.attrs['cn'] = 'Max'
    >>> p1.attrs['description'] = 'Initial Description'
    >>> customer['cn=max'] = p1
    >>> p2 = LDAPNode()
    >>> p2.attrs['objectClass'] = ['top', 'person']
    >>> p2.attrs['sn'] = 'Mueller'
    >>> p2.attrs['cn'] = 'Moritz'
    >>> p2.attrs['description'] = 'Initial Description'
    >>> customer['cn=Moritz'] = p2
    >>> customer()
    >>> customer.keys()
    [u'cn=max', u'cn=Moritz']

Now choose some attribute as key, its value needs to be unique - XXX This is an
experimental feature, there must not be any children listing this node as a
parent!::

    >>> node = LDAPNode(props=props, name=customer.DN)
    >>> node._key_attr = 'description'
    >>> node.keys()
    Traceback (most recent call last):
    ...
    RuntimeError: Key not unique: description='Initial Description'.

    >>> node = LDAPNode(props=props, name=customer.DN)
    >>> node._key_attr = 'objectClass'
    >>> node.keys()
    Traceback (most recent call last):
      ...
    KeyError: u"Expected one value for 'objectClass' not 2: '[u'top', u'person']'."
    
    >>> node = LDAPNode(props=props, name=customer.DN)
    >>> node._key_attr = 'sn'
    >>> node.keys()
    [u'Mustermann', u'Mueller']

Childs can be retrieved normally::

    >>> our_p1 = node['Mustermann']
    >>> our_p1
    <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:Mustermann - False>

The node is the real parent::

    >>> our_p1.parent is node
    True

The child knows its correct DN::

    >>> our_p1.DN
    u'cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com'

We can change attributes::

    >>> our_p1.attrs['description'] = 'foo'
    >>> root.printtree()
    <dc=my-domain,dc=com - False>
      <ou=customers,dc=my-domain,dc=com:ou=customers - False>
        <ou=customer1,ou=customers,dc=my-domain,dc=com:ou=customer1 - False>
        <ou=customer2,ou=customers,dc=my-domain,dc=com:ou=customer2 - False>
        <ou=n?sty\2C customer,ou=Customers,dc=My-Domain,dc=com:ou=n?sty\, customer - False>
        <ou=customer3,ou=customers,dc=my-domain,dc=com:ou=customer3 - False>
          <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=max - False>
          <cn=Moritz,ou=customer3,ou=customers,dc=my-domain,dc=com:cn=Moritz - False>
        <cn=customer99,ou=customers,dc=my-domain,dc=com:cn=customer99 - False>
    
    >>> node.printtree()
    <ou=customer3,ou=customers,dc=my-domain,dc=com - True>
      <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:Mustermann - True>
      <cn=Moritz,ou=customer3,ou=customers,dc=my-domain,dc=com:Mueller - False>
    
    >>> our_p1()
    >>> node.printtree()
    <ou=customer3,ou=customers,dc=my-domain,dc=com - False>
      <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:Mustermann - False>
      <cn=Moritz,ou=customer3,ou=customers,dc=my-domain,dc=com:Mueller - False>
    
    >>> p1.attrs.load()
    >>> p1.attrs['description']
    u'foo'

Addings items, if _rdn_attr is set::

    >>> node['foo'] = LDAPNode()
    Traceback (most recent call last):
    ...
    RuntimeError: Adding with key != rdn needs _rdn_attr to be set.

    >>> node._rdn_attr = 'cn'
    >>> node['foo'] = LDAPNode()
    Traceback (most recent call last):
    ...
    ValueError: 'cn' needed in node attributes for rdn.

    >>> newnode = LDAPNode()
    >>> newnode.attrs['cn'] = 'newnode'
    >>> newnode.attrs['objectClass'] = ['top', 'person']

XXX: these need to be the same as 'sn' if used as key

    >>> newnode.attrs['sn'] = 'foo'
    >>> node['foo'] = newnode

    >>> node.keys()
    [u'Mustermann', u'Mueller', u'foo']

    >>> node['foo'] is newnode
    True

    >>> node is newnode.parent
    True

    >>> newnode.name == 'foo'
    True

Commit the added node::

    >>> node.printtree()
    <ou=customer3,ou=customers,dc=my-domain,dc=com - True>
      <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:Mustermann - False>
      <cn=Moritz,ou=customer3,ou=customers,dc=my-domain,dc=com:Mueller - False>
      <cn=newnode,ou=customer3,ou=customers,dc=my-domain,dc=com:foo - True>

    >>> node()
    >>> node.printtree()
    <ou=customer3,ou=customers,dc=my-domain,dc=com - False>
      <cn=max,ou=customer3,ou=customers,dc=my-domain,dc=com:Mustermann - False>
      <cn=Moritz,ou=customer3,ou=customers,dc=my-domain,dc=com:Mueller - False>
      <cn=newnode,ou=customer3,ou=customers,dc=my-domain,dc=com:foo - False>

    >>> node._reload = True
    >>> node.keys()
    [u'Mustermann', u'Mueller', u'foo']

    >>> node['foo'].attrs.items()
    [(u'objectClass', [u'top', u'person']),
     (u'cn', u'newnode'),
     (u'sn', u'foo')]

And deleting again::

    >>> del node['Mueller']
    >>> del node['foo']
    >>> node()
    >>> node.keys()
    [u'Mustermann']
    
    >>> node()
    >>> customer._reload = True
    >>> customer.keys()
    [u'cn=max']

Using filter and scope. Let's first create a collision::

    >>> tmp = LDAPNode()
    >>> tmp.attrs['ou'] = 'customer3'
    >>> tmp.attrs['objectClass'] = ['top', 'organizationalUnit']
    >>> root['ou=customer3'] = tmp
    >>> root()

    >>> from node.ext.ldap import SUBTREE
    >>> node = LDAPNode(props=props, name=root.DN)
    >>> node.search_scope = SUBTREE
    >>> node.keys()
    Traceback (most recent call last):
    ...
    RuntimeError: Key not unique: rdn='ou=customer3'.

We need a different key. As a side-effect a filter will be used: '(cn=*)'::

    >>> node = LDAPNode(props=props, name=root.DN)
    >>> node.search_scope = SUBTREE
    >>> node._key_attr = 'cn'
    >>> node._rdn_attr = 'cn'
    >>> node.child_defaults = {'objectClass': ['top', 'person']}
    >>> node.keys()
    [u'customer99', u'Max']

Again, we can query/change/delete these::

    >>> max = node['Max']
    >>> node['Max'].attrs['description'] = 'bar'
    >>> node()
    >>> max.attrs['description']
    u'bar'

New entries in case of scope SUBTREE are added in the ONELEVEL scope::

    >>> newnode = LDAPNode()
    >>> newnode.attrs['sn'] = 'foosn'
    >>> node['foo'] = newnode
    >>> node['foo'] is newnode
    True
    
    >>> newnode.DN
    u'cn=foo,dc=my-domain,dc=com'
    
    >>> node.DN
    u'dc=my-domain,dc=com'

    >>> del node['Max']
    >>> node()
    >>> node.keys()
    [u'customer99', u'foo']

    >>> node = LDAPNode(props=props, name=root.DN)
    >>> node['cn=foo'].attrs['objectClass']
    [u'top', u'person']

Cleanup for following tests::

    >>> root = LDAPNode('dc=my-domain,dc=com', props)
    >>> del root['cn=foo']
    >>> root()
