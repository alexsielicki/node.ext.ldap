Tests refering to groupOfNames.ldif
===================================

Ugm root object::

    >>> props = layer['props']
    >>> ucfg = layer['ucfg']
    >>> gcfg = layer['gcfg']
    >>> rcfg = None # XXX: later
    
    >>> from node.ext.ldap._ugm import Ugm
    >>> ugm = Ugm(name='ugm', parent=None, props=props,
    ...           ucfg=ucfg, gcfg=gcfg, rcfg=rcfg)
    
    >>> ugm
    <Ugm object 'ugm' at ...>

Users object::

    >>> ugm.users
    <Users object 'users' at ...>
    
    >>> ugm['users'] is ugm.users
    True

Groups object::

    >>> ugm.groups
    <Groups object 'groups' at ...>
    
    >>> ugm['groups'] is ugm.groups
    True

Try to delete from UGM, fails::

    >>> del ugm['users']
    Traceback (most recent call last):
      ...
    NotImplementedError: Operation forbidden on this node.

Try to set item by invalid key, fails::

    >>> ugm['inexistent'] = ugm.users
    Traceback (most recent call last):
      ...
    KeyError: 'inexistent'

User keys::

    >>> users = ugm.users
    >>> users.keys()
    [u'uid0', u'uid1', u'uid2']

Fetch some users::

    >>> user_0 = users['uid0']
    >>> user_1 = users['uid1']
    >>> user_2 = users['uid2']

    >>> user_0
    <User object 'uid0' at ...>
    
    >>> user_0.__class__
    <class 'node.ext.ldap._ugm.User'>
    
    >>> user_0.attrs
    Aliased <LDAPNodeAttributes object '__attrs__' at ...>

    >>> user_0.attrs.items()
    [('login', u'cn0'), ('sn', u'sn0'), ('rdn', u'uid0')]
    
User is a leaf::

    >>> user_0['foo'] = object()
    Traceback (most recent call last):
      ...
    NotImplementedError: User object is a leaf.
    
    >>> del user_0['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError: User object is a leaf.
    
    >>> user_0['foo']
    Traceback (most recent call last):
      ...
    NotImplementedError: User object is a leaf.
    
    >>> user_0.keys()
    []

Authentication tests::

    >>> users.authenticate('uid0', 'secret0')
    'uid0'
    
    >>> users.authenticate('cn0', 'secret0')
    u'uid0'
    
    >>> users.authenticate('uid0', 'invalid')
    False
    
    >>> users.authenticate('cn0', 'invalid')
    False
    
    >>> users.authenticate('foo', 'secret0')
    False

Groups object::

    >>> groups = ugm.groups
    >>> groups.keys()
    [u'group0', u'group1', u'group2']

    >>> group_0 = groups['group0']
    >>> group_1 = groups['group1']
    >>> group_2 = groups['group2']

    >>> group_0
    <Group object 'group0' at ...>
    
    >>> group_0.__class__
    <class 'node.ext.ldap._ugm.Group'>
    
    >>> group_0.attrs
    Aliased <LDAPNodeAttributes object '__attrs__' at ...>
    
    >>> group_0.attrs.items()
    [('member', [u'cn=nobody']), ('rdn', u'group0')]
    
    >>> group_1.attrs.items()
    [('member', [u'cn=nobody', u'uid=uid1,ou=users,ou=groupOfNames,dc=my-domain,dc=com']), 
    ('rdn', u'group1')]

A group returns the members ids as keys::     

    >> group0.keys()
    []
    >> group1.keys()
    [u'uid1']
    >> group2.keys()
    [u'uid1', u'uid2']

The member users are fetched via ``getitem``::

    >> group1['uid1']
    <User 'uid1'>

XXX: This is not yet true as users creates a new node on every getitem::

    >> group1['uid1'] is user1
    False

Querying a group for a non-member results in a KeyError::

    >> group0['uid1']
    Traceback (most recent call last):
      ...
    KeyError: 'uid1'

Members are added via ``add``::

    >> group1.add(user0)
    >> group1.keys()
    [u'uid1', u'uid0']
    >> group1['uid0']
    <User 'uid0'>

Let's take a fresh view on ldap whether this really happened::

    >> groups_fresh = Groups(layer['props'], layer['gcfg'])
    >> groups_fresh.users = users
    >> groups_fresh['group1'].keys()
    [u'uid1', u'uid0']

Members are removed via ``delitem``::

    >> del group1['uid0']
    >> groups_fresh = Groups(layer['props'], layer['gcfg'])
    >> groups_fresh.users = users
    >> groups_fresh['group1'].keys()
    [u'uid1']

Once users knows groups, a user knows its groups::

    >> users.groups = groups
    >> user0.membership.keys()
    []
    >> user1.membership.keys()
    [u'group1', u'group2']
    >> user2.membership.keys()
    [u'group2']

and is able to return them::

    >> user0.membership['group1']
    Traceback (most recent call last):
      ...
    KeyError: 'group1'

    >> user1.membership['group1']
    <Group 'group1'>

and can remove and add itself to them::

    >> group1.keys()
    [u'uid1']
    >> user2.membership.add(group1)
    >> group1.keys()
    u'uid1', u'uid2']
    >> del user2.membership[group1.id]
    >> group1.keys()
    [u'uid1']
